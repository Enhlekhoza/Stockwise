import db from './db';
import * as fs from 'fs';
import * as path from 'path';
import { analyzeSecurityImage } from './security_service';

export interface SecurityAlert {
  id?: number; // Make id optional as it will be auto-generated by the database
  title: string;
  time: string;
  severity: 'High' | 'Medium' | 'Low';
  image: string; // URL path to image
  status: 'pending' | 'confirmed' | 'dismissed';
}

const iconicImagesDir = path.resolve(__dirname, '../dataset/GroceryStoreDataset/sample_images/iconic');
const naturalImagesDir = path.resolve(__dirname, '../dataset/GroceryStoreDataset/sample_images/natural');
const iconicImageFiles = fs.readdirSync(iconicImagesDir);
const naturalImageFiles = fs.readdirSync(naturalImagesDir);
const allImageFiles = [...iconicImageFiles, ...naturalImageFiles];

const generateAlert = async () => {
  const randomImageFile = allImageFiles[Math.floor(Math.random() * allImageFiles.length)];
  let imagePath;
  if (iconicImageFiles.includes(randomImageFile)) {
    imagePath = path.join(iconicImagesDir, randomImageFile);
  } else {
    imagePath = path.join(naturalImagesDir, randomImageFile);
  }
  const imageBuffer = fs.readFileSync(imagePath);
  const base64Image = imageBuffer.toString('base64');

  const analysisResult = await analyzeSecurityImage(base64Image);

  // Simple logic to determine severity based on keywords in the analysis
  let severity: 'High' | 'Medium' | 'Low' = 'Low';
  const lowerCaseAnalysis = analysisResult.toLowerCase(); // Convert to lower case for case-insensitive matching

  if (lowerCaseAnalysis.includes('theft') || lowerCaseAnalysis.includes('unauthorized access')) {
    severity = 'High';
  } else if (lowerCaseAnalysis.includes('suspicious') || lowerCaseAnalysis.includes('unusual behavior') || lowerCaseAnalysis.includes('out of place')) {
    severity = 'Medium';
  }

  const newAlert: Omit<SecurityAlert, 'id'> = { // Omit id as it's auto-generated
    title: analysisResult,
    time: new Date().toLocaleTimeString(),
    severity,
    image: `/images/${randomImageFile}`,
    status: 'pending',
  };

  try {
    await db('alerts').insert(newAlert);
  } catch (error) {
    console.error('Error inserting new alert into database:', error);
  }
};

// Generate an alert every 15 seconds
setInterval(generateAlert, 15000);

export const getSecurityAlerts = async (severityFilter?: 'High' | 'Medium' | 'Low', page: number = 1, limit: number = 10): Promise<SecurityAlert[]> => {
  let query = db('alerts').where({ status: 'pending' });

  if (severityFilter) {
    query = query.where({ severity: severityFilter });
  }

  const offset = (page - 1) * limit;

  const alerts = await query.orderBy('id', 'desc').limit(limit).offset(offset);
  return alerts;
};

export const confirmAlert = async (id: number) => {
  try {
    await db('alerts').where({ id }).update({ status: 'confirmed' });
  } catch (error) {
    console.error(`Error confirming alert ${id}:`, error);
  }
};

export const dismissAlert = async (id: number) => {
  try {
    await db('alerts').where({ id }).update({ status: 'dismissed' });
  } catch (error) {
    console.error(`Error dismissing alert ${id}:`, error);
  }
};
