import db from './db';
import { Product, getProductById } from './products';

interface TransactionItem {
  id?: number; // Optional as it will be auto-generated by the database
  productId: string; // ID from the product database
  name: string;
  price: number;
  quantity: number;
}

interface CurrentTransaction {
  userId: number; // Assuming a user is performing the transaction
  items: TransactionItem[];
  total: number;
  nextItemId: number; // To assign unique IDs to transaction items (for in-memory)
}

let currentTransaction: CurrentTransaction = {
  userId: 1, // Default user ID for now
  items: [],
  total: 0,
  nextItemId: 1,
};

export const getTransaction = (): CurrentTransaction => {
  // Return a deep copy to prevent external modification
  return JSON.parse(JSON.stringify(currentTransaction));
};

export const addItemToTransaction = async (productId: string): Promise<TransactionItem | undefined> => {
  const product = await getProductById(productId); // Await the async function
  if (!product) {
    return undefined;
  }

  // Check if item already exists in transaction, if so, increment quantity
  const existingItem = currentTransaction.items.find(item => item.productId === productId);
  if (existingItem) {
    existingItem.quantity++;
    currentTransaction.total += product.price;
    return existingItem;
  } else {
    const newItem: TransactionItem = {
      id: currentTransaction.nextItemId++, // Still use in-memory ID for current transaction building
      productId: product.id,
      name: product.name,
      price: product.price,
      quantity: 1,
    };
    currentTransaction.items.push(newItem);
    currentTransaction.total += product.price;
    return newItem;
  }
};

export const completeTransaction = async () => {
  const completedTransaction = getTransaction();

  if (completedTransaction.items.length === 0) {
    console.warn('Attempted to complete an empty transaction.');
    return null; // Or throw an error, depending on desired behavior
  }

  try {
    // Start a transaction for atomicity
    await db.transaction(async trx => {
      // Insert into transactions table
      const [transactionId] = await trx('transactions').insert({
        user_id: completedTransaction.userId,
        total: completedTransaction.total,
        created_at: db.fn.now(), // Use database timestamp
      }).returning('id');

      // Insert into transaction_items table
      const transactionItemsToInsert = completedTransaction.items.map(item => ({
        transaction_id: transactionId,
        product_id: item.productId,
        name: item.name,
        price: item.price,
        quantity: item.quantity,
      }));
      await trx('transaction_items').insert(transactionItemsToInsert);
    });

    // Reset current transaction after successful database operation
    currentTransaction = {
      userId: 1, // Reset to default user ID
      items: [],
      total: 0,
      nextItemId: 1,
    };
    return completedTransaction;
  } catch (error) {
    console.error('Error completing transaction and saving to database:', error);
    throw new Error('Failed to complete transaction.'); // Re-throw for API to catch
  }
};

export const cancelTransaction = () => {
  const cancelledTransaction = getTransaction();
  // Reset current transaction
  currentTransaction = {
    userId: 1, // Reset to default user ID
    items: [],
    total: 0,
    nextItemId: 1,
  };
  return cancelledTransaction;
};
